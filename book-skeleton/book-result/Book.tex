% -*- mode: LaTeX; -*-

\documentclass[a4paper,10pt,twoside]{book}
\usepackage[
        papersize={6.13in,9.21in},
        hmargin={.75in,.75in},
        vmargin={.75in,1in},
        ignoreheadfoot
]{geometry}
\input{../support/latex/common.tex}
% \input{../support/latex/commonLuaTex.tex}
\setboolean{lulu}{true}
%=================================================================
% Add the path for the figures of each chapter here:
\graphicspath{
        {../figures/}
        {../Example/}
}
%=================================================================
\let\wholebook=\relax
\makeindex
\makeglossary
%=================================================================
\renewcommand{\nnbb}[2]{} % Disable editorial comments
%=================================================================
\begin{document}
\frontmatter
%=================================================================
\setcounter{page}{1}
\pagestyle{headings}
%=================================================================
\author{
  <Put the authors here>
}
\title{\Huge\bf Roassal Layout - DRAFT }
\isodate
\date{\emph{Version of \today}}
\maketitle
%=================================================================
\tableofcontents
% \listoffigures
% \listoftables

% \lstlistoflistings
\sloppy % To avoid LaTeX's annoying habit of letting lines stick over the margins!
\mainmatter

\chapter{ GUI}

\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{figures/gui.png}\caption{DynaCASE window with highlighted important models.\label{figures/gui.png}}\end{center}
\end{figure}


\begin{itemize}
\item  DCWorkbench - top level window of DynaCASE
\item  topMenu - menu bar providing basic project operations
\item  DCNavigator - sidebar displaying all models available in the opened project
\item  DCEditor - composition of other widgets representing an opened diagram. DCEditors are organized as Spec Tabs
\end{itemize}

 - \ref{Palette/Palette} - palette of tools for interaction with the canvas
 - DCCanvasModel - Spec Model for Roassal's RTView

\begin{itemize}
\item  \ref{DCDynamicForm} - form for editing model values
\end{itemize}


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{figures/gui_composition.png}\caption{Composition between Spec models.\label{figures/gui_composition.png}}\end{center}
\end{figure}

\chapter{ Overall Architecture}\section{ DC $/$ Spec $/$ Roassal composition}
DynaCASE is attempting to follow in some respect MVC architecture.
\subsection{ Model}
The model itself is separated from the rest of the application and in fact can be used completely independently on any other part of the DynaCASE application.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/Models.png}\caption{file:$/$$/$..$/$figures$/$Models.png.\label{../figures/Models.png}}\end{center}
\end{figure}

Element represents a singular object within the model (e.g. UML class or UML generalization). Diagram then encompasses all elements applicable to the given model.

Project is abstraction on top of collection of diagrams. This is mainly for application use, however it can still be used independently. It is also aware of layout of each diagram.
\subsubsection{ Events}
Model is communicating with the outside world through it's API and events.

\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/Events.png}\caption{file:$/$$/$..$/$figures$/$Events.png.\label{../figures/Events.png}}\end{center}
\end{figure}


Added$/$Removed event is fired when an element is added$/$removed into a diagram. Change event is fired when either element or a digram has changed in any respect. This could be change of some value (e.g. name of an element), or for diagram when the collection of elements is changed. So for example when we add an element into diagram, both AddedEvent is fired from added element and ChangedEvent from the diagram.
\subsection{ Controllers}
Controllers provide binding between model, visualization and GUI. Generally each model is controlled by it's own controller (an appropriate descendant of DCController). The responsibility of controller is to update model when some outside event requests it (e.g. value is changed from a form), and in turn update the visualization (when model is changed).


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/All%20layers%20simplified.png}\caption{file:$/$$/$..$/$figures$/$All\%20layers\%20simplified.png.\label{../figures/All%20layers%20simplified.png}}\end{center}
\end{figure}


More complex and chaotic model of interactions between model, controllers, gui, roassal and trachel.

\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/Architecture%20layers.png}\caption{file:$/$$/$..$/$figures$/$Architecture\%20layers.png.\label{../figures/Architecture%20layers.png}}\end{center}
\end{figure}

\subsection{ View (Roassal)}
DynaCASE uses Roassal2 from \href{http://www.moosetechnology.org/}{Moose project}

Roassal (and Trachel) is well documented at \href{http://agilevisualization.com/#book}{Agile Visualization}

Visualisation comes in multiple layers, application itself interacts mostly only with the top one

\begin{itemize}
\item  Roassal
\item  Trachel (part of Roassal)
\item  Athens (part of Pharo)
\item  graphics library we should not care about
\end{itemize}
\subsubsection{ Roassal}
Roassal2 is layer for manipulation with visual aspects in high-level manners, for example manipulating with elements and connecting them with edges.

Main behavior and drawing via Roassal is based on these Roassal parts:

\begin{itemize}
\item  RTShapedObject (RTElement or RTEdge), which are semantic part, telling what we have and what is connected
\item  RTShape (RTEllipse, RTArrowedLine, etc.), which control what shapes and looks should elements and edges use
\item  RTView, which is where objects above take place
\end{itemize}

Most of interaction from Roassal TO application is made using events. Any object can tell (subscribe) RTAnnouncableObject (RTShapedObject and RTView) to make given action (announce) when given event occurs. For example, when mouse clicks on such object (Trachel event TRMouseClick occurs).
\subsubsection{ Trachel}
Trachel under it defines how exactly should shapes look (TRShape). All these shapes are drawn on surface called canvas (TRCanvas). For controlling what part of canvas is displayed Trachel uses TRCamera, defining zoom (scale), size and position of current crop of canvas.

Trachel uses callbacks, which are somewhat similar to announcements$/$events, making specified action if predefined events with Trachel shapes occur (when trachel object is resized, moved or removed).
\chapter{ Palette}
Palette is a UI widget providing a \textit{palette} of tools for interaction with the canvas.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/palette-example.png}\caption{Finite State Machine palette.\label{../figures/palette-example.png}}\end{center}
\end{figure}


Currently there are available three different kinds of tools.
\section{ Selection Tool}
The purpose of selection tool is to select objects in canvas. This tool is also selected by default and is also switched to after some other tool has completed its purposed action.
This tool is always available and cannot be removed.

Selecting an element will highlight this element while removing the highlight of previously selected element. Highlight behavior of each element can be controlled via \ct{DCController$>$$>$hideSelectionFeedback} and \ct{DCController$>$$>$showSelectionFeedback}.
Secondly selecting will also open editable form for this element (if provided). The form is to be specified in \ct{DCController$>$$>$buildEditorForm:}.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/selection%20sequence.png}\caption{file:$/$$/$..$/$figures$/$selection\%20sequence.png.\label{../figures/selection%20sequence.png}}\end{center}
\end{figure}

\section{ Creation Tool}
Creation tool is used to add new elements to the canvas. It can be added into the palette by sending \ct{DCPalette$>$$>$newCreationTool:factory:}. Factory should a block producing a new instance of element's DCController.
When adding a new element one always places the element inside a target - whether the canvas itself (represented by DCDiagramController) or another element (e.g. putting state inside statemachine region). To successfully add a new element the target must accept it, this is controlled by target's controller method \ct{DCController$>$$>$canBeTargetFor: aController}; by default nobody accepts anything. If the target accepts it, it must also implement method \ct{$>$$>$addAsTargetFor: aController} since the target is providing context within the new element is being created.

Similarly to selection highlighting, Creation Tool uses accept$/$deny feedback to display whether target element accepts the creation. This behavior is provided by \ct{DCAcceptDenyFeedbackBuilder} which at the moment displays green (accept) or red (deny) border around the target (or changes the color of a line if the target is an edge).


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/creation%20tool%20sequence.png}\caption{file:$/$$/$..$/$figures$/$creation\%20tool\%20sequence.png.\label{../figures/creation%20tool%20sequence.png}}\end{center}
\end{figure}

\section{ Connection Creation Tool}
\ct{DCPalette$>$$>$newConnectionCreationTool: aLabel factory: aBlock}
This is a tool for creating connections between two other existing elements. The basis of functionality is similar to creation tool, but with two main differences.
The first is that \ct{DCController$>$$>$canBeTargetFor:} (and \ct{DCController$>$$>$addAsTargetFor:}) is used for the second connected element, while for the specification of the first one there is \ct{DCController$>$$>$canBeSourceFor:} (resp. \ct{DCController$>$$>$addAsSourceFor:}).
Secondly the new element's controller is must implement \ct{DCRelationshipController$>$$>$connectionFeedback}. This provides visual feedback for the newly created line before it is finalized - essentially a connection between the source element and current mouse position. {[}{[}Pkg-DynaCASE-Roassal2\#DCInteractiveLine\textbar{}DCInteractiveLine{]}{]} can be used to simplify creation of the feedback.


\begin{figure}

\begin{center}
\includegraphics[width=1.0\textwidth]{../figures/connection%20creation%20tool%20sequence.png}\caption{An attempt to visualize ConnectionCreationTool's behavior.\label{../figures/connection%20creation%20tool%20sequence.png}}\end{center}
\end{figure}

\section{ Separator}
Currently there is no support for groups - so one cannot logically group together tools. As a temporary replacement one can add separator to provide extra horizontal spacing between tools. \ct{DCPalette$>$$>$newSeparator}
\section{ Example}

\begin{code}{}
aPalette
	newCreationTool: 'element' "tool label"
		factory: [ ElementController new ] "a descendant of DCElementController"
		icon: Smalltalk ui icons nautilusIcon; "optional icon"
	newSeparator; "add extra spacing"
	newConnectionCreationTool: 'edge'
		factory: [ TransitionController new ] "a descendant of DCRelationshipController"
\end{code}

\chapter{ Form}
To be able to edit a model through a form you need model's controller to describe what and how should be edited.

Override \ct{DCController$>$$>$buildEditorForm:} and describe all the elements required. The recieved \ct{aForm} argument is an instance of \ct{DCDynamicForm}.


\begin{code}{}
buildEditorForm: aForm
	"base class automatically adds edit field for `name`"
	super buildEditorForm: aForm.

	(aForm addText: 'Alternative name')
		text: self model altName;
		whenTextIsAccepted: [ :newValue | self model altName: newValue ].
\end{code}


All \ct{add*:} methods of \ct{DCDynamicForm} return appropriate \textit{Spec} models, so you have their full API at your disposal.
The argument of \ct{add*:} is a string label that will be displayed alongside the control.

The description of available controls follows.
\section{ \ct{addLabel:}}
Add a single label.

\begin{code}{}
aForm addLabel: aString.
\end{code}

Usually not needed as all the other methods add their own label automatically.
\section{ \ct{addText:}}
Add a multiline text area.

\begin{code}{}
(aForm addText: aString)
	text: aString; "set the value of the input"
	whenTextIsAccepted: [ :newValue | ]. "observed change"
\end{code}

\section{ \ct{addTextInput:}}
Add a single line text field.

\begin{code}{}
(aForm addText: aString)
	text: aString; "set the value"
	whenTextIsAccepted: [ :newValue | ].
\end{code}

\section{ \ct{addCheckbox:}}
Add a single checkbox.


\begin{code}{}
(aForm addCheckbox: aString)
	state: aBoolean; "set the state"
	whenChangedDo: [ :aBool | ]. "observed change"
\end{code}

\section{ \ct{addDroplist:}}
Add a droplist with specified items.


\begin{code}{}
(aForm addDroplist: aString)
	items: #(#opt1 #opt2); "collection of options available in the droplist"
	displayBlock: [ :item | item asString ]; "if items are complex object, specify what should be displayed"
	setSelectedItem: oneOfTheItems; "set specific value"
	whenSelectedItemChanged: [ :newValue | ]. "observed change"
\end{code}


For particularities of the models consult Spec's documentation.
\chapter{ Pkg-DynaCASE-Roassal2}
This package contains classes which extend the Roassal2 for DynaCASE purposes.
Roassal2 is layer for manipulation with visual aspects in high-level manners, for example manipulating with elements and connecting them with edges.
\section{ Builders}
Contains classes used to prepare and create other classes and elements.
\subsection{ Feedback builders}
Serve for visualising whether given edge, element, view etc. can or can not be used withing current context.
\href{../figures/connection%20creation%20tool%20sequence.png}{usage for connection creation}.
\subsection{ DCRTCallbackBuilder}\subsection{ DCRTEdgeBuilder}
Serve for creation of lines and edges used in DC
\subsection{ DCStarAssociationBuilder}
Handler for visualisation of association between multiple elements, connected with 'star topology'. Usable for example for generalization.
\section{ Core}\subsection{ Constraints}
Constraint classes are inspired by TRConstraint classes, which serve to adapt element's properties according to other element(s).

EdgeConstraint are applicable only for positioning of an element according to properties (mostly position) of roassal edge.
'Along' constraint uses relative position from center of line (based also on lenght of line), 'End' constraint uses distance of start or end of line.

ElementsConstaint are applicable only for two elements.
\subsection{ DCRTToSelf(WithOffset)AttachPoint}
A DCRTToSelfAttachPoint is attachpoint for connecting an element with itself.
Offset version: If multiple connections are made, each one has its attach point moved by offset.
\section{ Interactivity}\subsection{ DCInteractiveLine}
Temporary line displayed while creating associations. After the first element is chosen, it shows how could the line look like at the current moment.
\href{../figures/connection%20creation%20tool%20sequence.png}{usage for connection creation}
\subsection{ DCRTFocusable}
Implementation of RTAbstractHighlightable, highlighting an element or edge when the item is clicked. Previously selected item automatically loses focus.
\section{ Line Decoration}
System of classes used as replacement for Roassal2 RTLineDecoration classes, which serve as line heads (for example with arrowed line).
DCRTLineHead (and DCRTLineTail) could be used in place of RTLineDecoration classes, acting like them.
DCRTLineDecorationShape and its subclasses define its shape.
\section{ Shapes}\subsection{ DCRTClass}
Rectangle-shaped standard class, containing name (and stereotype) in upper part and attributes in lower part.
\subsection{ DCRTMultiLine}
Multi-purpose line with possibility of being made from multiple parts, having head and$/$or tail (like arrow) and being styled (dashed, dotted...).
\chapter{ Pkg-DynaCASE-Trachel}
This package contains classes which extend the Trachel (from Roassal2 project) for DynaCASE purposes.
Trachel is layer which defines visual aspects, for example shapes definition and canvas manipulation.
\section{ Core}\subsection{ DCTRConstraint}
A DCTRConstraint is an extension of Trachel TRContraint (which serve to adapt element's properties according to other element(s)).
\subsection{ (DC)TRCanvasExporter}
Class used for exporting Trachel canvas into various raster images.
Has been included into Roassal itself with name DCTRCanvasExporter, but here is more current version. Will be deleted when updated in Roassal.
\section{ Shapes}

% another try
% \printglossary
\bibliographystyle{jurabib}
\bibliography{scg}

\printindex

\end{document}

%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
