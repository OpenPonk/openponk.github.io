{
    "docs": [
        {
            "location": "/", 
            "text": "OpenPonk (formerly DynaCASE) is a metamodeling platform and a modeling workbench implemented in the dynamic environment \nPharo\n aimed at supporting activities surrounding software and business engineering such as modeling, execution, simulation, source code generation, etc.\n\n\nShowcase video for \nESUG 2016 conference\n\n\n\n\n\nDownload\n\n\nYou can download preinstalled Pharo image containing all currently supported notations:\n\n\n\n\nFSM - Finite State Machines\n\n\nBORM ORD \u2014 \nBusiness Objects Relation Modeling\n Object-Relation Diagrams\n\n\n\nUML Class Diagrams\n\n\n\n\nKeep in mind that OpenPonk is still in early development and contains many bugs and missing features.\n\n\nWe are also performing a major overhaul of many parts (such as working on a full UML 2.5 metamodel, creating user documentation, and more) and we plan to do a release in late summer 2017.\n\n\nAlpha\n is a semi-stable version, but possibly outdated compared to bleeding edge.\n\n\n\n\n\n\n\n\nBuild\n\n\nLinux \n\n\nMac \n\n\nWindows \n\n\nimage only \n\n\n\n\n\n\n\n\n\n\nall-in-one (alpha)\n\n\ndownload\n\n\ndownload\n\n\ndownload\n\n\ndownload\n\n\n\n\n\n\n\n\nBleeding edge\n is the very latest version that passed CI, but is still possibly broken.\n\n\n\n\n\n\n\n\nBuild\n\n\nLinux \n\n\nMac \n\n\nWindows \n\n\nimage only \n\n\n\n\n\n\n\n\n\n\nall-in-one (bleeding edge)\n\n\ndownload\n\n\ndownload\n\n\ndownload\n\n\ndownload\n\n\n\n\n\n\n\n\nDirect installation\n\n\nTo install OpenPonk with all default plugins to an existing image, use the following snippet:\n\n\nMetacello\n \nnew\n\n    \nbaseline:\n \nOpenPonk\n;\n\n    \nrepository:\n \ngithub://openponk/openponk/repository\n;\n\n    \nload:\n \ncomplete\n\n\n\n\n\n\nOpening\n\n\nThe downloaded package contains \nREADME.md\n with additional instructions, however on properly configured system launching \nopenponk.sh\n (under Linux \n Mac) or \nOpenPonk.exe\n (under Windows) should be sufficient.\n\n\nOnce launched, clicking on the desktop will show a menu containing entries for OpenPonk.\n\n\nRequirements\n\n\nWindows and Mac should work out of the box.\n\n\nLinux may require extra configuration\n as Pharo VM is still primarily 32bit. Please refer to Pharo's \nofficial guide\n.\n\n\nAdditionally you will require 32bit \ncairo2\n library, usually available in distribution package managers as \nlibcairo2\n:\ni386\n (debian), \nlibcairo2\n, etc.\n\n\nThe bundled launcher will check those requirements and will warn you and provide some tips if your system is not configured properly.", 
            "title": "OpenPonk"
        }, 
        {
            "location": "/#download", 
            "text": "You can download preinstalled Pharo image containing all currently supported notations:   FSM - Finite State Machines  BORM ORD \u2014  Business Objects Relation Modeling  Object-Relation Diagrams  UML Class Diagrams   Keep in mind that OpenPonk is still in early development and contains many bugs and missing features.  We are also performing a major overhaul of many parts (such as working on a full UML 2.5 metamodel, creating user documentation, and more) and we plan to do a release in late summer 2017.  Alpha  is a semi-stable version, but possibly outdated compared to bleeding edge.     Build  Linux   Mac   Windows   image only       all-in-one (alpha)  download  download  download  download     Bleeding edge  is the very latest version that passed CI, but is still possibly broken.     Build  Linux   Mac   Windows   image only       all-in-one (bleeding edge)  download  download  download  download", 
            "title": "Download"
        }, 
        {
            "location": "/#direct-installation", 
            "text": "To install OpenPonk with all default plugins to an existing image, use the following snippet:  Metacello   new \n     baseline:   OpenPonk ; \n     repository:   github://openponk/openponk/repository ; \n     load:   complete", 
            "title": "Direct installation"
        }, 
        {
            "location": "/#opening", 
            "text": "The downloaded package contains  README.md  with additional instructions, however on properly configured system launching  openponk.sh  (under Linux   Mac) or  OpenPonk.exe  (under Windows) should be sufficient.  Once launched, clicking on the desktop will show a menu containing entries for OpenPonk.", 
            "title": "Opening"
        }, 
        {
            "location": "/#requirements", 
            "text": "Windows and Mac should work out of the box.  Linux may require extra configuration  as Pharo VM is still primarily 32bit. Please refer to Pharo's  official guide .  Additionally you will require 32bit  cairo2  library, usually available in distribution package managers as  libcairo2 : i386  (debian),  libcairo2 , etc.  The bundled launcher will check those requirements and will warn you and provide some tips if your system is not configured properly.", 
            "title": "Requirements"
        }, 
        {
            "location": "/dev/installation/", 
            "text": "Installation\n\n\nCore\n\n\n\n\nDownload latest Pharo 6.1 image\n\n\nEnable Iceberg Metacello integration in settings\n\n\nClone \nhttps://github.com/OpenPonk/openponk\n repository via Iceberg\n\n\nLoad the \ndefault\n baseline.\n\n\n\n\nChoosing the \ncomplete\n baseline instead will install the default editors (UML, FSM, BORM).\n\n\nEditors\n\n\nTo load a specific editor, add it in the same way to Iceberg and load the \ndefault\n baseline.", 
            "title": "Installation"
        }, 
        {
            "location": "/dev/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/dev/installation/#core", 
            "text": "Download latest Pharo 6.1 image  Enable Iceberg Metacello integration in settings  Clone  https://github.com/OpenPonk/openponk  repository via Iceberg  Load the  default  baseline.   Choosing the  complete  baseline instead will install the default editors (UML, FSM, BORM).", 
            "title": "Core"
        }, 
        {
            "location": "/dev/installation/#editors", 
            "text": "To load a specific editor, add it in the same way to Iceberg and load the  default  baseline.", 
            "title": "Editors"
        }, 
        {
            "location": "/dev/overview/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nOverall Architecture\n\n\nOpenPonk is attempting to follow in some respect MVC architecture.\n\n\nModel\n\n\nThe model itself is separated from the rest of the application and in fact can be used completely independently on any other part of the OpenPonk application.\n\n\n\n\nElement represents a singular object within the model (e.g. UML class or UML generalization). Diagram then encompasses all elements applicable to the given model.\n\n\nProject is abstraction on top of collection of diagrams. This is mainly for application use, however it can still be used independently. It is also aware of layout of each diagram.\n\n\nEvents\n\n\nModel is communicating with the outside world through it's API and events.\n\n\n\nAdded/Removed event is fired when an element is added/removed into a diagram. Change event is fired when either element or a digram has changed in any respect. This could be change of some value (e.g. name of an element), or for diagram when the collection of elements is changed. So for example when we add an element into diagram, both AddedEvent is fired from added element and ChangedEvent from the diagram.\n\n\nControllers\n\n\nControllers provide binding between model, visualization and GUI. Generally each model is controlled by it's own controller (an appropriate descendant of DCController). The responsibility of controller is to update model when some outside event requests it (e.g. value is changed from a form), and in turn update the visualization (when model is changed).\n\n\n\n\nMore complex and chaotic model of interactions between model, controllers, gui, roassal and trachel.\n\n\n\nView (Roassal)\n\n\nOpenPonk uses Roassal2 from \nMoose project\n\n\nRoassal (and Trachel) is well documented at \nAgile Visualization\n\n\nVisualisation comes in multiple layers, application itself interacts mostly only with the top one\n\n\n\n\nRoassal\n\n\nTrachel (part of Roassal)\n\n\nAthens (part of Pharo)\n\n\ngraphics library we should not care about\n\n\n\n\nRoassal\n\n\nRoassal2 is layer for manipulation with visual aspects in high-level manners, for example manipulating with elements and connecting them with edges.\n\n\nMain behavior and drawing via Roassal is based on these Roassal parts:\n\n\n\n\n\n\nRTShapedObject (RTElement or RTEdge), which are semantic part, telling what we have and what is connected\n\n\nRTShape (RTEllipse, RTArrowedLine, etc.), which control what shapes and looks should elements and edges use\n\n\nRTView, which is where objects above take place\n\n\n\n\nMost of interaction from Roassal TO application is made using events. Any object can tell (subscribe) RTAnnouncableObject (RTShapedObject and RTView) to make given action (announce) when given event occurs. For example, when mouse clicks on such object (Trachel event TRMouseClick occurs).\n\n\nTrachel\n\n\nTrachel under it defines how exactly should shapes look (TRShape). All these shapes are drawn on surface called canvas (TRCanvas). For controlling what part of canvas is displayed Trachel uses TRCamera, defining zoom (scale), size and position of current crop of canvas.\n\n\nTrachel uses callbacks, which are somewhat similar to announcements/events, making specified action if predefined events with Trachel shapes occur (when trachel object is resized, moved or removed).", 
            "title": "Overview"
        }, 
        {
            "location": "/dev/overview/#overall-architecture", 
            "text": "OpenPonk is attempting to follow in some respect MVC architecture.", 
            "title": "Overall Architecture"
        }, 
        {
            "location": "/dev/overview/#model", 
            "text": "The model itself is separated from the rest of the application and in fact can be used completely independently on any other part of the OpenPonk application.   Element represents a singular object within the model (e.g. UML class or UML generalization). Diagram then encompasses all elements applicable to the given model.  Project is abstraction on top of collection of diagrams. This is mainly for application use, however it can still be used independently. It is also aware of layout of each diagram.", 
            "title": "Model"
        }, 
        {
            "location": "/dev/overview/#events", 
            "text": "Model is communicating with the outside world through it's API and events.  Added/Removed event is fired when an element is added/removed into a diagram. Change event is fired when either element or a digram has changed in any respect. This could be change of some value (e.g. name of an element), or for diagram when the collection of elements is changed. So for example when we add an element into diagram, both AddedEvent is fired from added element and ChangedEvent from the diagram.", 
            "title": "Events"
        }, 
        {
            "location": "/dev/overview/#controllers", 
            "text": "Controllers provide binding between model, visualization and GUI. Generally each model is controlled by it's own controller (an appropriate descendant of DCController). The responsibility of controller is to update model when some outside event requests it (e.g. value is changed from a form), and in turn update the visualization (when model is changed).   More complex and chaotic model of interactions between model, controllers, gui, roassal and trachel.", 
            "title": "Controllers"
        }, 
        {
            "location": "/dev/overview/#view-40roassal41", 
            "text": "OpenPonk uses Roassal2 from  Moose project  Roassal (and Trachel) is well documented at  Agile Visualization  Visualisation comes in multiple layers, application itself interacts mostly only with the top one   Roassal  Trachel (part of Roassal)  Athens (part of Pharo)  graphics library we should not care about", 
            "title": "View (Roassal)"
        }, 
        {
            "location": "/dev/overview/#roassal", 
            "text": "Roassal2 is layer for manipulation with visual aspects in high-level manners, for example manipulating with elements and connecting them with edges.  Main behavior and drawing via Roassal is based on these Roassal parts:    RTShapedObject (RTElement or RTEdge), which are semantic part, telling what we have and what is connected  RTShape (RTEllipse, RTArrowedLine, etc.), which control what shapes and looks should elements and edges use  RTView, which is where objects above take place   Most of interaction from Roassal TO application is made using events. Any object can tell (subscribe) RTAnnouncableObject (RTShapedObject and RTView) to make given action (announce) when given event occurs. For example, when mouse clicks on such object (Trachel event TRMouseClick occurs).", 
            "title": "Roassal"
        }, 
        {
            "location": "/dev/overview/#trachel", 
            "text": "Trachel under it defines how exactly should shapes look (TRShape). All these shapes are drawn on surface called canvas (TRCanvas). For controlling what part of canvas is displayed Trachel uses TRCamera, defining zoom (scale), size and position of current crop of canvas.  Trachel uses callbacks, which are somewhat similar to announcements/events, making specified action if predefined events with Trachel shapes occur (when trachel object is resized, moved or removed).", 
            "title": "Trachel"
        }, 
        {
            "location": "/dev/gui/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nGUI\n\n\n\n\nOpenPonk window with highlighted important models\n\n\n\n\nDCWorkbench - top level window of OpenPonk\n\n\ntopMenu - menu bar providing basic project operations\n\n\nDCNavigator - sidebar displaying all models available in the opened project\n\n\nDCEditor - composition of other widgets representing an opened diagram. DCEditors are organized as Spec Tabs\n\n\nDCPalette - palette of tools for interaction with the canvas\n\n\nDCCanvasModel - Spec Model for Roassal's RTView\n\n\n\n\n\n\nDCForm - form for editing model values\n\n\n\n\n\nComposition between Spec models", 
            "title": "GUI"
        }, 
        {
            "location": "/dev/gui/#gui", 
            "text": "OpenPonk window with highlighted important models   DCWorkbench - top level window of OpenPonk  topMenu - menu bar providing basic project operations  DCNavigator - sidebar displaying all models available in the opened project  DCEditor - composition of other widgets representing an opened diagram. DCEditors are organized as Spec Tabs  DCPalette - palette of tools for interaction with the canvas  DCCanvasModel - Spec Model for Roassal's RTView    DCForm - form for editing model values   \nComposition between Spec models", 
            "title": "GUI"
        }, 
        {
            "location": "/dev/plugin/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nCreating new plugin\n\n\nPlugin definition class\n\n\nTo provide basic description for your plugin subclass \nDCPlugin\n and provide basic information.\n\n\nName of the plugin\n\nMyCustomPlugin\nname\n    ^ \nMy Custom Plugin\n\n\n\nToplevel class of the diagram\n\nMyCustomPlugin\nmodelClass\n    ^ MCPDiagram\n\n\nController for the diagramClass\n\nMyCustomPlugin\ndiagramControllerClass\n    ^ MCPDiagramController\n\n\nIcon, 16x16 Form instance\n\nMyCustomPlugin\nicon\n    ^ Smalltalk ui icons databaseIcon\n\n\nClass responsible for serializing the model and diagram to text format\n\nMyCustomPlugin\nserializerClass\n    ^ DCNullSerializer", 
            "title": "New plugin"
        }, 
        {
            "location": "/dev/plugin/#creating-new-plugin", 
            "text": "", 
            "title": "Creating new plugin"
        }, 
        {
            "location": "/dev/plugin/#plugin-definition-class", 
            "text": "To provide basic description for your plugin subclass  DCPlugin  and provide basic information.  Name of the plugin \nMyCustomPlugin name\n    ^  My Custom Plugin  Toplevel class of the diagram \nMyCustomPlugin modelClass\n    ^ MCPDiagram Controller for the diagramClass \nMyCustomPlugin diagramControllerClass\n    ^ MCPDiagramController Icon, 16x16 Form instance \nMyCustomPlugin icon\n    ^ Smalltalk ui icons databaseIcon Class responsible for serializing the model and diagram to text format \nMyCustomPlugin serializerClass\n    ^ DCNullSerializer", 
            "title": "Plugin definition class"
        }, 
        {
            "location": "/dev/navigator/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nDCNavigator\n\n\n\n\nNavigator is a tree view of your project (models).\n\n\nAs semantics of models vary, it may be needed to explicitly\nspecify what kind of relations are between elements, what are elements\nnamed, or what kind of icon should accompany it.\n\n\nTo do this, simply subclass \nDCNavigatorAdapter\n and define your mappings.\nIf you do not specify some mapping (or do not create your adapter at all),\nthe default one will be used instead \nDCDefaultNavigatorAdapter\n.\n\n\nMappings\n\n\nThe mapping itself is an array of mappings\n\n\nmodel class -\n block/symbol/object\n\n\ne.g.\n\n\nDCFsmVertex -\n #outgoing\n\n\nIf the right value is block or symbol, it will be applied on actual model.\nSo \n#outgoing\n is equivalent to [ :vertex | vertex outgoing ].\nIf it is some other object (string, collection, \u2026), it will be returned\nas specified.\n\n\n\n\nchildrenMapping\n\n\nChildren mapping defines what elements should be displayed as children\nin the navigator.\n\n\nDCFsmNavigatorAdapter\nchildrenMapping\n    ^ {\n        DCFsm -\n #states. \nshow all states of the diagram as children\n\n        DCFsmVertex -\n #outgoing. \nshow all outgoing transitions\n\n        DCFsmTransition -\n #() \ntransition has no children\n\n    }\n\n\n\n\n\ndisplayMapping\n\n\n\n\nRename it to displaySuffixMapping?\n\nDisplay mapping customizes the suffix of the displayed string, by default\nthe class name is displayed\n(so element named \"Example\" of class \"DCDiagram\" will show \nExample (DCDiagram)\n).\n\n\n\n\nDCFsmNavigatorAdapter\ndisplayMapping\n    ^ {\n        DCFsm -\n \nDiagram\n.\n        DCFsmInitialState -\n \nInitial State\n.\n        DCFsmState -\n [ :o | o isNormal\n            ifTrue: [ \nState\n ]\n            ifFalse: [ \nFinal State\n ]\n        ].\n        DCFsmTransition -\n \nTransition\n\n    }\n\n\n\n\n\niconMapping\n\n\nIcon mapping defines the icon displayed for the item. Icon is a 16x16 \nForm\n instance.\nIf you want to ease creation of icons, you can use \nhttp://smalltalkhub.com/#!/~peteruhnak/IconFactory\n\n\n\n\nDCFsmNavigatorAdapter\niconMapping\n    ^ {\n        DCFsm -\n DCIcons current dcFsmDiagramIcon.\n        DCFsmInitialState -\n DCIcons current dcFsmInitialStateIcon.\n        DCFsmTransition -\n DCIcons current dcFsmTransitionIcon.\n    }\n\n\n\n\n\nactionMapping\n\n\n\n\nThis is not yet implemented.\n\nIn the future action mapping should define the action that occures when double clicking on an element.\nCurrently this is hardcoded to have no action for elements and open diagram for diagram.\n\n\nmenuMapping\n\n\n\n\nThis is not yet implemented.\n\nThis will control menu displayed on right mouse click, currently there are only basic options available like Rename, Inspect, and Delete.\n\n\nUsing same mapping for hierarchy of classes\n\n\nWhen looking for mapping for an object, it's class hierarchy is used starting from the most generic one and stopping on the first match.\n\n\nSo for hierarchy\n\n\n\n\nDCNamedElement\n |\n |- DCFsmVertex\n     |\n     |- DCFsmInitialState\n     |- DCFsmState\n\n\n\n\n\nyou can specify the mapping for any class in the hierarchy.\n\n\nNote:\n if you use class too far up in the hierarchy, like \nDCNamedElement\n you will also need a way to tell that your particular mapping is\nonly for your specific model, e.g. any subclass of \nDCNamedElement\n, but only if the object is part of \nFSM\n plugin.\n\n\nTo do so, override method \nhasMappingFor:\n\n\n\n\nDCFsmNavigatorAdapter\nhasMappingFor: anObject\n    ^ anObject className beginsWith: \nDCFsm\n \ndefine whatever rule you want as long as it returns boolean", 
            "title": "Navigator"
        }, 
        {
            "location": "/dev/navigator/#dcnavigator", 
            "text": "Navigator is a tree view of your project (models).  As semantics of models vary, it may be needed to explicitly\nspecify what kind of relations are between elements, what are elements\nnamed, or what kind of icon should accompany it.  To do this, simply subclass  DCNavigatorAdapter  and define your mappings.\nIf you do not specify some mapping (or do not create your adapter at all),\nthe default one will be used instead  DCDefaultNavigatorAdapter .", 
            "title": "DCNavigator"
        }, 
        {
            "location": "/dev/navigator/#mappings", 
            "text": "The mapping itself is an array of mappings  model class -  block/symbol/object  e.g.  DCFsmVertex -  #outgoing  If the right value is block or symbol, it will be applied on actual model.\nSo  #outgoing  is equivalent to [ :vertex | vertex outgoing ].\nIf it is some other object (string, collection, \u2026), it will be returned\nas specified.", 
            "title": "Mappings"
        }, 
        {
            "location": "/dev/navigator/#childrenmapping", 
            "text": "Children mapping defines what elements should be displayed as children\nin the navigator.  DCFsmNavigatorAdapter childrenMapping\n    ^ {\n        DCFsm -  #states.  show all states of the diagram as children \n        DCFsmVertex -  #outgoing.  show all outgoing transitions \n        DCFsmTransition -  #()  transition has no children \n    }", 
            "title": "childrenMapping"
        }, 
        {
            "location": "/dev/navigator/#displaymapping", 
            "text": "Rename it to displaySuffixMapping? \nDisplay mapping customizes the suffix of the displayed string, by default\nthe class name is displayed\n(so element named \"Example\" of class \"DCDiagram\" will show  Example (DCDiagram) ).   DCFsmNavigatorAdapter displayMapping\n    ^ {\n        DCFsm -   Diagram .\n        DCFsmInitialState -   Initial State .\n        DCFsmState -  [ :o | o isNormal\n            ifTrue: [  State  ]\n            ifFalse: [  Final State  ]\n        ].\n        DCFsmTransition -   Transition \n    }", 
            "title": "displayMapping"
        }, 
        {
            "location": "/dev/navigator/#iconmapping", 
            "text": "Icon mapping defines the icon displayed for the item. Icon is a 16x16  Form  instance.\nIf you want to ease creation of icons, you can use  http://smalltalkhub.com/#!/~peteruhnak/IconFactory   DCFsmNavigatorAdapter iconMapping\n    ^ {\n        DCFsm -  DCIcons current dcFsmDiagramIcon.\n        DCFsmInitialState -  DCIcons current dcFsmInitialStateIcon.\n        DCFsmTransition -  DCIcons current dcFsmTransitionIcon.\n    }", 
            "title": "iconMapping"
        }, 
        {
            "location": "/dev/navigator/#actionmapping", 
            "text": "This is not yet implemented. \nIn the future action mapping should define the action that occures when double clicking on an element.\nCurrently this is hardcoded to have no action for elements and open diagram for diagram.", 
            "title": "actionMapping"
        }, 
        {
            "location": "/dev/navigator/#menumapping", 
            "text": "This is not yet implemented. \nThis will control menu displayed on right mouse click, currently there are only basic options available like Rename, Inspect, and Delete.", 
            "title": "menuMapping"
        }, 
        {
            "location": "/dev/navigator/#using-same-mapping-for-hierarchy-of-classes", 
            "text": "When looking for mapping for an object, it's class hierarchy is used starting from the most generic one and stopping on the first match.  So for hierarchy   DCNamedElement\n |\n |- DCFsmVertex\n     |\n     |- DCFsmInitialState\n     |- DCFsmState  you can specify the mapping for any class in the hierarchy.  Note:  if you use class too far up in the hierarchy, like  DCNamedElement  you will also need a way to tell that your particular mapping is\nonly for your specific model, e.g. any subclass of  DCNamedElement , but only if the object is part of  FSM  plugin.  To do so, override method  hasMappingFor:   DCFsmNavigatorAdapter hasMappingFor: anObject\n    ^ anObject className beginsWith:  DCFsm   define whatever rule you want as long as it returns boolean", 
            "title": "Using same mapping for hierarchy of classes"
        }, 
        {
            "location": "/dev/menus/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nExtending menus\n\n\nYou can extend both Workspace and Editor menus.\n\n\nWorkbench menu\n\n\nTo add an item to the \nEditor\n item in the Workbench menu, create a method on the \nclass-side\n of some class, preferably the class of your Plugin.\n\n\nDCFsmPlugin\n \nclass\ntoolbarFor:\n \naBuilder\n\n    \ndcEditorToolbarMenu:\n #DCFsmPlugin\n\n    (\naBuilder\n \nitem:\n \nHelp\n)\n        \nicon:\n \nSmalltalk\n \nui\n \nicons\n \nhelp\n;\n\n        \naction:\n [ \nHelpBrowser\n \nopenOn:\n \nDCFsmHelp\n ]\n\n\n\n\n\nYou can name the method however you want, but you must include the \ndcEditorToolbarMenu:\n pragma.\n\n\nThe pragma takes as the argument the name of the plugin you wish the menu to be associated with; this way you can register the menu item from any class:\n\n\nDCFsmSimulator\n \nclass\ntoolbarFor:\n \naBuilder\n\n    \ndcEditorToolbarMenu:\n #DCFsmPlugin\n\n    (\naBuilder\n \nitem:\n \nOpen Simulator\n)\n        \naction:\n [ \nDCFsmSimulator\n \nnew\n \nopenOn:\n \naBuilder\n \nmodel\n \ndiagramController\n ]\n\n\n\n\n\nThe menu items will be automatically collected from all methods matching the pragma and the plugin name:\n\n\n\n\nToo see all the available options you can specify for the menu item (submenu, icon, description, \u2026) see the protocol of \nPragmaMenuAndShortcutRegistrationItem\n.\n\n\nFinally \naBuilder model\n keeps a reference to the appropriate \nDCEditor\n instance.\n\n\nEditor menu\n\n\nThe Editor menu is placed underneath the canvas, and works on the same principle.\n\n\nYou just need to name the pragma \ndcCanvasToolbar:\n.\n\n\nDCUmlClassPlugin\ncanvasToolbarFor:\n \naBuilder\n\n    \ndcCanvasToolbar:\n #DCUmlClassPlugin\n\n    (\naBuilder\n \nitem:\n \nLayout\n) \naction:\n [  ]\n.\n\n    \naBuilder\n \nmodel\n \ndiagramController\n \naddLayoutMenu:\n \naBuilder\n \nparent:\n \nLayout\n\n\n\nDCUmlClassDiagramController\naddLayoutMenu:\n \nbuilder\n \nparent:\n \naParent\n\n    \n|\n classes inheritance associations centerY \n|\n\n    ...\n    (\nbuilder\n \nitem:\n \nSugiyama\n)\n        \nparent:\n \naParent\n;\n\n        \naction:\n [ \nRTSugiyamaLayout\n \nnew\n\n                \ndoNotAttachPoint\n;\n\n                \nverticalGap:\n \n100\n;\n\n                \nhorizontalGap:\n \n100\n;\n\n                \non:\n \nclasses\n \nedges:\n \ninheritance\n.\n\n            \nself\n \nview\n \nsignalUpdate\n ]\n.\n\n\n\n\n\n\nHere \naBuilder model\n holds a reference to the appropriate \nDCCanvasModel\n instance.", 
            "title": "Extending menus"
        }, 
        {
            "location": "/dev/menus/#extending-menus", 
            "text": "You can extend both Workspace and Editor menus.", 
            "title": "Extending menus"
        }, 
        {
            "location": "/dev/menus/#workbench-menu", 
            "text": "To add an item to the  Editor  item in the Workbench menu, create a method on the  class-side  of some class, preferably the class of your Plugin.  DCFsmPlugin   class toolbarFor:   aBuilder \n     dcEditorToolbarMenu:  #DCFsmPlugin \n    ( aBuilder   item:   Help )\n         icon:   Smalltalk   ui   icons   help ; \n         action:  [  HelpBrowser   openOn:   DCFsmHelp  ]  You can name the method however you want, but you must include the  dcEditorToolbarMenu:  pragma.  The pragma takes as the argument the name of the plugin you wish the menu to be associated with; this way you can register the menu item from any class:  DCFsmSimulator   class toolbarFor:   aBuilder \n     dcEditorToolbarMenu:  #DCFsmPlugin \n    ( aBuilder   item:   Open Simulator )\n         action:  [  DCFsmSimulator   new   openOn:   aBuilder   model   diagramController  ]  The menu items will be automatically collected from all methods matching the pragma and the plugin name:   Too see all the available options you can specify for the menu item (submenu, icon, description, \u2026) see the protocol of  PragmaMenuAndShortcutRegistrationItem .  Finally  aBuilder model  keeps a reference to the appropriate  DCEditor  instance.", 
            "title": "Workbench menu"
        }, 
        {
            "location": "/dev/menus/#editor-menu", 
            "text": "The Editor menu is placed underneath the canvas, and works on the same principle.  You just need to name the pragma  dcCanvasToolbar: .  DCUmlClassPlugin canvasToolbarFor:   aBuilder \n     dcCanvasToolbar:  #DCUmlClassPlugin \n    ( aBuilder   item:   Layout )  action:  [  ] . \n     aBuilder   model   diagramController   addLayoutMenu:   aBuilder   parent:   Layout  DCUmlClassDiagramController addLayoutMenu:   builder   parent:   aParent \n     |  classes inheritance associations centerY  | \n    ...\n    ( builder   item:   Sugiyama )\n         parent:   aParent ; \n         action:  [  RTSugiyamaLayout   new \n                 doNotAttachPoint ; \n                 verticalGap:   100 ; \n                 horizontalGap:   100 ; \n                 on:   classes   edges:   inheritance . \n             self   view   signalUpdate  ] .   Here  aBuilder model  holds a reference to the appropriate  DCCanvasModel  instance.", 
            "title": "Editor menu"
        }, 
        {
            "location": "/dev/palette/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nPalette\n\n\nPalette is a UI widget providing a \npalette\n of tools for interaction with the canvas.\n\n\n\n\nCurrently there are available three different kinds of tools.\n\n\nSelection Tool\n\n\nThe purpose of selection tool is to select objects in canvas. This tool is also selected by default and is also switched to after some other tool has completed its purposed action.\nThis tool is always available and cannot be removed.\n\n\nSelecting an element will highlight this element while removing the highlight of previously selected element. Highlight behavior of each element can be controlled via \nDCController\nhideSelectionFeedback\n and \nDCController\nshowSelectionFeedback\n.\nSecondly selecting will also open editable form for this element (if provided). The form is to be specified in \nDCController\nbuildEditorForm:\n.\n\n\n\n\nCreation Tool\n\n\nCreation tool is used to add new elements to the canvas. It can be added into the palette by sending \nDCPalette\nnewCreationTool:factory:\n. Factory should a block producing a new instance of element's DCController.\nWhen adding a new element one always places the element inside a target - whether the canvas itself (represented by DCDiagramController) or another element (e.g. putting state inside statemachine region). To successfully add a new element the target must accept it, this is controlled by target's controller method \nDCController\ncanBeTargetFor: aController\n; by default nobody accepts anything. If the target accepts it, it must also implement method \naddAsTargetFor: aController\n since the target is providing context within the new element is being created.\n\n\nSimilarly to selection highlighting, Creation Tool uses accept/deny feedback to display whether target element accepts the creation. This behavior is provided by \nDCAcceptDenyFeedbackBuilder\n which at the moment displays green (accept) or red (deny) border around the target (or changes the color of a line if the target is an edge).\n\n\n\n\nConnection Creation Tool\n\n\nDCPalette\nnewConnectionCreationTool: aLabel factory: aBlock\n\nThis is a tool for creating connections between two other existing elements. The basis of functionality is similar to creation tool, but with two main differences.\nThe first is that \nDCController\ncanBeTargetFor:\n (and \nDCController\naddAsTargetFor:\n) is used for the second connected element, while for the specification of the first one there is \nDCController\ncanBeSourceFor:\n (resp. \nDCController\naddAsSourceFor:\n).\nSecondly the new element's controller is must implement \nDCRelationshipController\nconnectionFeedback\n. This provides visual feedback for the newly created line before it is finalized - essentially a connection between the source element and current mouse position. [[Pkg-OpenPonk-Roassal2#DCInteractiveLine|DCInteractiveLine]] can be used to simplify creation of the feedback.\n\n\n\n\nSeparator\n\n\nCurrently there is no support for groups - so one cannot logically group together tools. As a temporary replacement one can add separator to provide extra horizontal spacing between tools. \nDCPalette\nnewSeparator\n\n\nExample\n\n\naPalette\n\n    \nnewCreationTool\n:\n \nelement\n \ntool label\n\n        \nfactory\n:\n \n[\n \nElementController\n \nnew\n \n]\n \na descendant of DCElementController\n\n        \nicon\n:\n \nSmalltalk\n \nui\n \nicons\n \nnautilusIcon\n;\n \noptional icon\n\n    \nnewSeparator\n;\n \nadd extra spacing\n\n    \nnewConnectionCreationTool\n:\n \nedge\n\n        \nfactory\n:\n \n[\n \nTransitionController\n \nnew\n \n]\n \na descendant of DCRelationshipController", 
            "title": "Palette"
        }, 
        {
            "location": "/dev/palette/#palette", 
            "text": "Palette is a UI widget providing a  palette  of tools for interaction with the canvas.   Currently there are available three different kinds of tools.", 
            "title": "Palette"
        }, 
        {
            "location": "/dev/palette/#selection-tool", 
            "text": "The purpose of selection tool is to select objects in canvas. This tool is also selected by default and is also switched to after some other tool has completed its purposed action.\nThis tool is always available and cannot be removed.  Selecting an element will highlight this element while removing the highlight of previously selected element. Highlight behavior of each element can be controlled via  DCController hideSelectionFeedback  and  DCController showSelectionFeedback .\nSecondly selecting will also open editable form for this element (if provided). The form is to be specified in  DCController buildEditorForm: .", 
            "title": "Selection Tool"
        }, 
        {
            "location": "/dev/palette/#creation-tool", 
            "text": "Creation tool is used to add new elements to the canvas. It can be added into the palette by sending  DCPalette newCreationTool:factory: . Factory should a block producing a new instance of element's DCController.\nWhen adding a new element one always places the element inside a target - whether the canvas itself (represented by DCDiagramController) or another element (e.g. putting state inside statemachine region). To successfully add a new element the target must accept it, this is controlled by target's controller method  DCController canBeTargetFor: aController ; by default nobody accepts anything. If the target accepts it, it must also implement method  addAsTargetFor: aController  since the target is providing context within the new element is being created.  Similarly to selection highlighting, Creation Tool uses accept/deny feedback to display whether target element accepts the creation. This behavior is provided by  DCAcceptDenyFeedbackBuilder  which at the moment displays green (accept) or red (deny) border around the target (or changes the color of a line if the target is an edge).", 
            "title": "Creation Tool"
        }, 
        {
            "location": "/dev/palette/#connection-creation-tool", 
            "text": "DCPalette newConnectionCreationTool: aLabel factory: aBlock \nThis is a tool for creating connections between two other existing elements. The basis of functionality is similar to creation tool, but with two main differences.\nThe first is that  DCController canBeTargetFor:  (and  DCController addAsTargetFor: ) is used for the second connected element, while for the specification of the first one there is  DCController canBeSourceFor:  (resp.  DCController addAsSourceFor: ).\nSecondly the new element's controller is must implement  DCRelationshipController connectionFeedback . This provides visual feedback for the newly created line before it is finalized - essentially a connection between the source element and current mouse position. [[Pkg-OpenPonk-Roassal2#DCInteractiveLine|DCInteractiveLine]] can be used to simplify creation of the feedback.", 
            "title": "Connection Creation Tool"
        }, 
        {
            "location": "/dev/palette/#separator", 
            "text": "Currently there is no support for groups - so one cannot logically group together tools. As a temporary replacement one can add separator to provide extra horizontal spacing between tools.  DCPalette newSeparator", 
            "title": "Separator"
        }, 
        {
            "location": "/dev/palette/#example", 
            "text": "aPalette \n     newCreationTool :   element   tool label \n         factory :   [   ElementController   new   ]   a descendant of DCElementController \n         icon :   Smalltalk   ui   icons   nautilusIcon ;   optional icon \n     newSeparator ;   add extra spacing \n     newConnectionCreationTool :   edge \n         factory :   [   TransitionController   new   ]   a descendant of DCRelationshipController", 
            "title": "Example"
        }, 
        {
            "location": "/dev/form/", 
            "text": "Possibly outdated\n\n\nThis page is possibly outdates and is pending review.\n\n\n\n\nForm\n\n\nTo be able to edit a model through a form you need model's controller to describe what and how should be edited.\n\n\nOverride \nDCController\nbuildEditorForm:\n and describe all the elements required. The recieved \naForm\n argument is an instance of \nDCDynamicForm\n.\n\n\nbuildEditorForm\n:\n \naForm\n\n    \nbase class automatically adds edit field for `name`\n\n    \nsuper\n \nbuildEditorForm\n:\n \naForm\n.\n\n\n    \n(\naForm\n \naddText\n:\n \nAlternative name\n)\n\n        \ntext\n:\n \nself\n \nmodel\n \naltName\n;\n\n        \nwhenTextIsAccepted\n:\n \n[\n \n:\nnewValue\n \n|\n \nself\n \nmodel\n \naltName\n:\n \nnewValue\n \n].\n\n\n\n\n\n\nAll \nadd*:\n methods of \nDCDynamicForm\n return appropriate \nSpec\n models, so you have their full API at your disposal.\nThe argument of \nadd*:\n is a string label that will be displayed alongside the control.\n\n\nThe description of available controls follows.\n\n\naddLabel:\n\n\nAdd a single label.\n\n\n\n\naForm addLabel: aString.\n\n\n\n\n\nUsually not needed as all the other methods add their own label automatically.\n\n\naddText:\n\n\nAdd a multiline text area.\n\n\n\n\n(\naForm\n \naddText\n:\n \naString\n)\n\n    \ntext\n:\n \naString\n;\n \nset the value of the input\n\n    \nwhenTextIsAccepted\n:\n \n[\n \n:\nnewValue\n \n|\n \n]\n.\n \nobserved change\n\n\n\n\n\n\naddTextInput:\n\n\nAdd a single line text field.\n\n\n\n\n(\naForm\n \naddText\n:\n \naString\n)\n\n    \ntext\n:\n \naString\n;\n \nset the value\n\n    \nwhenTextIsAccepted\n:\n \n[\n \n:\nnewValue\n \n|\n \n]\n.\n\n\n\n\n\n\naddCheckbox:\n\n\nAdd a single checkbox.\n\n\n\n\n(\naForm\n \naddCheckbox\n:\n \naString\n)\n\n    \nstate\n:\n \naBoolean\n;\n \nset the state\n\n    \nwhenChangedDo\n:\n \n[\n \n:\naBool\n \n|\n \n]\n.\n \nobserved change\n\n\n\n\n\n\naddDroplist:\n\n\nAdd a droplist with specified items.\n\n\n\n\n(\naForm\n \naddDroplist\n:\n \naString\n)\n\n    \nitems\n:\n \n#\n(\n#\nopt1\n \n#\nopt2\n);\n \ncollection of options available in the droplist\n\n    \ndisplayBlock\n:\n \n[\n \n:\nitem\n \n|\n \nitem\n \nasString\n \n]\n;\n \nif items are complex object, specify what should be displayed\n\n    \nsetSelectedItem\n:\n \noneOfTheItems\n;\n \nset specific value\n\n    \nwhenSelectedItemChanged\n:\n \n[\n \n:\nnewValue\n \n|\n \n]\n.\n \nobserved change\n\n\n\n\n\n\nFor particularities of the models consult Spec's documentation.", 
            "title": "Form"
        }, 
        {
            "location": "/dev/form/#form", 
            "text": "To be able to edit a model through a form you need model's controller to describe what and how should be edited.  Override  DCController buildEditorForm:  and describe all the elements required. The recieved  aForm  argument is an instance of  DCDynamicForm .  buildEditorForm :   aForm \n     base class automatically adds edit field for `name` \n     super   buildEditorForm :   aForm . \n\n     ( aForm   addText :   Alternative name ) \n         text :   self   model   altName ; \n         whenTextIsAccepted :   [   : newValue   |   self   model   altName :   newValue   ].   All  add*:  methods of  DCDynamicForm  return appropriate  Spec  models, so you have their full API at your disposal.\nThe argument of  add*:  is a string label that will be displayed alongside the control.  The description of available controls follows.", 
            "title": "Form"
        }, 
        {
            "location": "/dev/form/#addlabel", 
            "text": "Add a single label.   aForm addLabel: aString.  Usually not needed as all the other methods add their own label automatically.", 
            "title": "addLabel:"
        }, 
        {
            "location": "/dev/form/#addtext", 
            "text": "Add a multiline text area.   ( aForm   addText :   aString ) \n     text :   aString ;   set the value of the input \n     whenTextIsAccepted :   [   : newValue   |   ] .   observed change", 
            "title": "addText:"
        }, 
        {
            "location": "/dev/form/#addtextinput", 
            "text": "Add a single line text field.   ( aForm   addText :   aString ) \n     text :   aString ;   set the value \n     whenTextIsAccepted :   [   : newValue   |   ] .", 
            "title": "addTextInput:"
        }, 
        {
            "location": "/dev/form/#addcheckbox", 
            "text": "Add a single checkbox.   ( aForm   addCheckbox :   aString ) \n     state :   aBoolean ;   set the state \n     whenChangedDo :   [   : aBool   |   ] .   observed change", 
            "title": "addCheckbox:"
        }, 
        {
            "location": "/dev/form/#adddroplist", 
            "text": "Add a droplist with specified items.   ( aForm   addDroplist :   aString ) \n     items :   # ( # opt1   # opt2 );   collection of options available in the droplist \n     displayBlock :   [   : item   |   item   asString   ] ;   if items are complex object, specify what should be displayed \n     setSelectedItem :   oneOfTheItems ;   set specific value \n     whenSelectedItemChanged :   [   : newValue   |   ] .   observed change   For particularities of the models consult Spec's documentation.", 
            "title": "addDroplist:"
        }
    ]
}